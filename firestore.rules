rules_version = '2';

service cloud.firestore {
  // Helper functions for messaging permissions
  
  // Check if user has access to a specific child
  function hasChildAccess(userId, childId) {
    return exists(/databases/$(database)/documents/child_access/$(userId + '_' + childId));
  }
  
  // Check if user is authenticated
  function isAuthenticated() {
    return request.auth != null;
  }
  
  // Check if user is participant in conversation
  function isConversationParticipant(conversationId, userId) {
    return userId in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
  }
  
  // Check if conversation is active
  function isConversationActive(conversationId) {
    let conversation = get(/databases/$(database)/documents/conversations/$(conversationId)).data;
    return !('isActive' in conversation) || conversation.isActive == true;
  }
  
  // Main collection rules
  match /databases/{database}/documents {
    
    // Existing collections (keeping current rules)
    // TODO: Review and update existing rules as needed
    
    // Users collection - basic user profile access
    match /users/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // Child access control
    match /child_access/{accessId} {
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.userId || 
         request.auth.uid in resource.data.sharedWith);
    }
    
    // Children collection
    match /children/{childId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, childId);
    }
    
    // === NEW MESSAGING COLLECTIONS ===
    
    // Conversations collection
    match /conversations/{conversationId} {
      // Allow read if user is a participant and has access to the child
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.participants &&
        hasChildAccess(request.auth.uid, resource.data.childId) &&
        isConversationActive(conversationId);
      
      // Allow create if user has child access and includes themselves as participant
      allow create: if isAuthenticated() &&
        hasChildAccess(request.auth.uid, request.resource.data.childId) &&
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.createdBy == request.auth.uid &&
        // Validate required fields
        request.resource.data.keys().hasAll(['participants', 'childId', 'type', 'title', 'createdBy']) &&
        request.resource.data.participants is list &&
        request.resource.data.participants.size() >= 2 &&
        request.resource.data.participants.size() <= 20 &&
        request.resource.data.type in ['group', 'direct'] &&
        request.resource.data.title is string &&
        request.resource.data.title.size() > 0 &&
        request.resource.data.title.size() <= 100;
      
      // Allow update if user is participant (for unread counts, last message, etc.)
      allow update: if isAuthenticated() &&
        request.auth.uid in resource.data.participants &&
        hasChildAccess(request.auth.uid, resource.data.childId) &&
        isConversationActive(conversationId) &&
        // Prevent changing core conversation data
        request.resource.data.childId == resource.data.childId &&
        request.resource.data.participants == resource.data.participants &&
        request.resource.data.createdBy == resource.data.createdBy;
      
      // Only creator can delete (deactivate)
      allow delete: if isAuthenticated() &&
        request.auth.uid == resource.data.createdBy;
    }
    
    // Messages collection
    match /messages/{messageId} {
      // Allow read if user is participant in the conversation
      allow read: if isAuthenticated() &&
        exists(/databases/$(database)/documents/conversations/$(resource.data.conversationId)) &&
        isConversationParticipant(resource.data.conversationId, request.auth.uid) &&
        isConversationActive(resource.data.conversationId);
      
      // Allow create if user is participant in conversation
      allow create: if isAuthenticated() &&
        exists(/databases/$(database)/documents/conversations/$(request.resource.data.conversationId)) &&
        isConversationParticipant(request.resource.data.conversationId, request.auth.uid) &&
        isConversationActive(request.resource.data.conversationId) &&
        request.resource.data.senderId == request.auth.uid &&
        // Validate required fields
        request.resource.data.keys().hasAll(['conversationId', 'senderId', 'senderName', 'type', 'text']) &&
        request.resource.data.conversationId is string &&
        request.resource.data.senderId is string &&
        request.resource.data.senderName is string &&
        request.resource.data.type in ['text', 'image', 'incident_share', 'system'] &&
        request.resource.data.text is string &&
        request.resource.data.text.size() <= 2000;
      
      // Allow update for read receipts and editing own messages
      allow update: if isAuthenticated() &&
        exists(/databases/$(database)/documents/conversations/$(resource.data.conversationId)) &&
        isConversationParticipant(resource.data.conversationId, request.auth.uid) &&
        isConversationActive(resource.data.conversationId) &&
        (
          // Updating read receipts
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'updatedAt'])) ||
          // Editing own message (text only)
          (request.auth.uid == resource.data.senderId &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'isEdited', 'updatedAt']) &&
           request.resource.data.text is string &&
           request.resource.data.text.size() <= 2000)
        );
      
      // Allow delete only for message sender or conversation creator
      allow delete: if isAuthenticated() &&
        exists(/databases/$(database)/documents/conversations/$(resource.data.conversationId)) &&
        (request.auth.uid == resource.data.senderId ||
         request.auth.uid == get(/databases/$(database)/documents/conversations/$(resource.data.conversationId)).data.createdBy);
    }
    
    // Message attachments collection (for future file references)
    match /message_attachments/{attachmentId} {
      allow read, write: if isAuthenticated() &&
        exists(/databases/$(database)/documents/messages/$(resource.data.messageId)) &&
        exists(/databases/$(database)/documents/conversations/$(get(/databases/$(database)/documents/messages/$(resource.data.messageId)).data.conversationId)) &&
        isConversationParticipant(
          get(/databases/$(database)/documents/messages/$(resource.data.messageId)).data.conversationId, 
          request.auth.uid
        );
    }
    
    // Existing collections - incident, daily_logs, etc.
    // TODO: Add/update rules for existing collections as needed
    match /incidents/{incidentId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, resource.data.childId);
    }
    
    match /daily_logs/{logId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, resource.data.childId);
    }
    
    match /journal_entries/{entryId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, resource.data.childId);
    }
    
    match /follow_ups/{followUpId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, resource.data.childId);
    }
    
    match /custom_categories/{categoryId} {
      allow read, write: if isAuthenticated() && 
        hasChildAccess(request.auth.uid, resource.data.childId);
    }
    
    // User preferences
    match /user_preferences/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
  }
}