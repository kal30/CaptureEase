rules_version = '2';

/*
 * CAPTUREEASE FIRESTORE SECURITY RULES
 * ====================================
 * 
 * ROLE-BASED ACCESS CONTROL SYSTEM:
 * 
 * CareOwner (CARE_OWNER):
 *   - Full admin access to child data
 *   - Can manage all users and permissions  
 *   - Can read/write all child-related collections
 *   - Can create/update/delete child documents
 *   - Medical access: Full read/write access
 * 
 * Care Partner (CARE_PARTNER): 
 *   - Can read/write daily care, habits, incidents
 *   - Can participate in messaging
 *   - Medical access: Can edit own medical entries, read existing
 *   - Cannot manage roles or delete child data
 * 
 * Caregiver (CAREGIVER):
 *   - Can read/write daily care, habits, incidents  
 *   - Can participate in messaging
 *   - Medical access: BLOCKED from reading medical data
 *   - Cannot manage roles or delete child data
 * 
 * Therapist (THERAPIST):
 *   - Can read most child data
 *   - Can participate in messaging  
 *   - BLOCKED from writing daily care, habits, incidents
 *   - Medical access: Can read medical data
 *   - Cannot manage roles or delete child data
 * 
 * COLLECTIONS:
 *   - /children: Child profile documents with role arrays
 *   - /dailyCare: Consolidated daily tracking (mood, sleep, food, energy)
 *   - /incidents: Incident/observation reports  
 *   - /conversations: Messaging conversations
 *   - /messages: Individual messages within conversations
 *   - /children/{childId}/*: Legacy subcollections (timeline, logs, etc.)
 */

service cloud.firestore {

  // ==== Helpers (inlined; Firestore includes are not supported) ====
  function isAuthenticated() {
    return request.auth != null;
  }

  // Single-source access: prefer users.members; fall back to role arrays with null guards
  function hasChildAccess(uid, childId) {
    return uid != null &&
           exists(/databases/(default)/documents/children/$(childId)) &&
           get(/databases/(default)/documents/children/$(childId)).data.users != null &&
           (
             (get(/databases/(default)/documents/children/$(childId)).data.users.members != null && uid in get(/databases/(default)/documents/children/$(childId)).data.users.members) ||
             get(/databases/(default)/documents/children/$(childId)).data.users.care_owner == uid ||
             (get(/databases/(default)/documents/children/$(childId)).data.users.care_partners != null && uid in get(/databases/(default)/documents/children/$(childId)).data.users.care_partners) ||
             (get(/databases/(default)/documents/children/$(childId)).data.users.caregivers != null && uid in get(/databases/(default)/documents/children/$(childId)).data.users.caregivers) ||
             (get(/databases/(default)/documents/children/$(childId)).data.users.therapists != null && uid in get(/databases/(default)/documents/children/$(childId)).data.users.therapists)
           );
  }

  function isChildOwner(childId) {
    return isAuthenticated() &&
           exists(/databases/(default)/documents/children/$(childId)) &&
           get(/databases/(default)/documents/children/$(childId)).data.users != null &&
           get(/databases/(default)/documents/children/$(childId)).data.users.care_owner == request.auth.uid;
  }

  // Role checks for current resource or request payload
  function hasChildRoleForResource(role) {
    return isAuthenticated() &&
           resource.data.childId != null &&
           exists(/databases/(default)/documents/children/$(resource.data.childId)) &&
           get(/databases/(default)/documents/children/$(resource.data.childId)).data.users != null &&
           get(/databases/(default)/documents/children/$(resource.data.childId)).data.users[role] != null &&
           request.auth.uid in get(/databases/(default)/documents/children/$(resource.data.childId)).data.users[role];
  }

  function hasChildRoleForRequest(role) {
    return isAuthenticated() &&
           request.resource.data.childId != null &&
           exists(/databases/(default)/documents/children/$(request.resource.data.childId)) &&
           get(/databases/(default)/documents/children/$(request.resource.data.childId)).data.users != null &&
           get(/databases/(default)/documents/children/$(request.resource.data.childId)).data.users[role] != null &&
           request.auth.uid in get(/databases/(default)/documents/children/$(request.resource.data.childId)).data.users[role];
  }

  // Read helper used by several collections
  function canReadChildData() {
    return isAuthenticated() && resource.data.childId != null && hasChildAccess(request.auth.uid, resource.data.childId);
  }

  // Incident/logs creation: owner, partners, caregivers (NOT therapists)
  function canCreateIncidentLogs() {
    return isAuthenticated() && request.resource.data.childId != null && hasChildAccess(request.auth.uid, request.resource.data.childId) && !(hasChildRoleForRequest('therapists'));
  }

  // Update for incidents/logs: owner can edit any; otherwise author-only (NOT therapists)
  function canUpdateIncidentLogs() {
    return isAuthenticated() && resource.data.childId != null && hasChildAccess(request.auth.uid, resource.data.childId) && ( isChildOwner(resource.data.childId) || (request.auth.uid == resource.data.createdBy && !hasChildRoleForResource('therapists')) );
  }

  // Soft delete pattern: allow setting status to 'deleted' by owner or author
  function canSoftDelete() {
    return isAuthenticated() && resource.data.childId != null && hasChildAccess(request.auth.uid, resource.data.childId) && request.resource.data.status == 'deleted' && (isChildOwner(resource.data.childId) || request.auth.uid == resource.data.createdBy);
  }

  // Medical helpers
  function canCreateMedical() {
    return isAuthenticated() && request.resource.data.childId != null && (isChildOwner(request.resource.data.childId) || hasChildRoleForRequest('care_partners'));
  }

  function canUpdateMedical() {
    return isAuthenticated() && resource.data.childId != null && 
           (isChildOwner(resource.data.childId) || 
            (hasChildRoleForResource('care_partners') && request.auth.uid == resource.data.createdBy));
  }

  // Medical read access - block caregivers from reading medical data
  function canReadMedical() {
    return isAuthenticated() && resource.data.childId != null && 
           (isChildOwner(resource.data.childId) || 
            hasChildRoleForResource('care_partners') || 
            hasChildRoleForResource('therapists'));
  }

  // Messaging helpers
  function isConversationParticipant(conversationId, uid) {
    return conversationId != null &&
           exists(/databases/(default)/documents/conversations/$(conversationId)) &&
           get(/databases/(default)/documents/conversations/$(conversationId)).data.participants != null &&
           uid in get(/databases/(default)/documents/conversations/$(conversationId)).data.participants;
  }

  function isConversationActive(conversationId) {
    return conversationId != null &&
           exists(/databases/(default)/documents/conversations/$(conversationId)) &&
           !(get(/databases/(default)/documents/conversations/$(conversationId)).data.status != null && get(/databases/(default)/documents/conversations/$(conversationId)).data.status == 'archived');
  }

  // Simple validators used by incident create
  function isValidRequiredString(val, maxLen) {
    return val is string && val.size() > 0 && val.size() <= maxLen;
  }

  function isValidOptionalString(val, maxLen) {
    return val == null || (val is string && val.size() <= maxLen);
  }

  function isValidSeverity(sev) {
    return sev == null || sev in ['low','medium','high'];
  }

  // Validation functions for data integrity
  function hasValidIncidentLogFields() {
    return request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
  }

  function hasValidMedicalFields() {
    return request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
  }

  // Main collection rules
  match /databases/{database}/documents {
    
    
    // Existing collections (keeping current rules)
    // TODO: Review and update existing rules as needed
    
    // Users collection - basic user profile access
    match /users/{userId} {
      // Allow users to read any authenticated user's profile (for care team display)
      allow read: if isAuthenticated();
      // Only allow users to write to their own profile
      allow write: if isAuthenticated() && request.auth.uid == userId;
    }

    // Children collection (minimal & deterministic)
    match /children/{childId} {
      // Read: only members of active children (with null guards)
      allow read: if isAuthenticated() &&
        resource.data.users != null &&
        resource.data.users.members != null &&
        request.auth.uid in resource.data.users.members &&
        resource.data.status == 'active';

      // Create: caller sets themselves as owner and includes themselves in members (with null guards)
      allow create: if isAuthenticated() &&
        request.resource.data.users != null &&
        request.resource.data.users.members != null &&
        request.resource.data.users.care_owner == request.auth.uid &&
        request.auth.uid in request.resource.data.users.members;

      // Update: owner-only
      allow update: if isAuthenticated() && isChildOwner(childId);

      // Hard delete not allowed (soft delete handled elsewhere if needed)
      
      // === CHILD SUBCOLLECTIONS ===
      // Timeline and incident-related subcollections for legacy data
      
      // Progress notes subcollection
      match /progressNotes/{noteId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      // Timeline entries subcollection  
      match /timeline/{entryId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      // Habit tracking subcollections
      match /sensoryLogs/{logId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /behaviors/{behaviorId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /moodLogs/{moodId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /medicationLogs/{medicationId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /foodLogs/{foodId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /sleepLogs/{sleepId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      match /medicalEvents/{eventId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
      
      // Custom incident categories subcollection
      match /customIncidentCategories/{categoryId} {
        allow read, write: if isAuthenticated() && hasChildAccess(request.auth.uid, childId);
      }
    }

    // Child access is now handled through the children collection directly
    
    // === NEW MESSAGING COLLECTIONS ===
    
    // Conversations collection with auth/exists/null guards
    match /conversations/{conversationId} {
      // Allow read if user is a participant and has access to the child with guards
      allow read: if isAuthenticated() && 
        conversationId != null &&
        resource != null && 
        resource.data != null &&
        resource.data.participants != null &&
        resource.data.childId != null &&
        request.auth.uid in resource.data.participants &&
        hasChildAccess(request.auth.uid, resource.data.childId) &&
        isConversationActive(conversationId);
      
      // Allow create if user has child access and includes themselves as participant with guards
      allow create: if isAuthenticated() &&
        request.resource != null &&
        request.resource.data != null &&
        request.resource.data.childId != null &&
        request.resource.data.participants != null &&
        request.resource.data.createdBy != null &&
        hasChildAccess(request.auth.uid, request.resource.data.childId) &&
        request.auth.uid in request.resource.data.participants &&
        request.resource.data.createdBy == request.auth.uid &&
        // Validate required fields - more flexible
        request.resource.data.keys().hasAll(['participants', 'childId', 'type', 'createdBy']) &&
        request.resource.data.participants is list &&
        request.resource.data.participants.size() >= 1 &&
        request.resource.data.participants.size() <= 20 &&
        request.resource.data.type in ['group', 'direct'] &&
        // Title can be empty string or missing for auto-generation
        (!('title' in request.resource.data) || 
         (request.resource.data.title is string && request.resource.data.title.size() <= 100));
      
      // Allow update if user is participant (for unread counts, last message, etc.) with guards
      allow update: if isAuthenticated() &&
        conversationId != null &&
        resource != null && 
        resource.data != null &&
        resource.data.participants != null &&
        resource.data.childId != null &&
        request.resource != null &&
        request.resource.data != null &&
        request.auth.uid in resource.data.participants &&
        hasChildAccess(request.auth.uid, resource.data.childId) &&
        isConversationActive(conversationId) &&
        // Prevent changing core conversation data
        request.resource.data.childId == resource.data.childId &&
        request.resource.data.participants == resource.data.participants &&
        request.resource.data.createdBy == resource.data.createdBy;
      
      // Only creator can delete (deactivate) with guards
      allow delete: if isAuthenticated() &&
        resource != null && 
        resource.data != null &&
        resource.data.createdBy != null &&
        request.auth.uid == resource.data.createdBy;
    }
    
    // Messages collection with auth/exists/null guards
    match /messages/{messageId} {
      // Allow read if user is participant in the conversation with guards
      allow read: if isAuthenticated() &&
        messageId != null &&
        resource != null && 
        resource.data != null &&
        resource.data.conversationId != null &&
        exists(/databases/(default)/documents/conversations/$(resource.data.conversationId)) &&
        isConversationParticipant(resource.data.conversationId, request.auth.uid) &&
        isConversationActive(resource.data.conversationId);
      
      // Allow create if user is participant in conversation with guards
      allow create: if isAuthenticated() &&
        request.resource != null &&
        request.resource.data != null &&
        request.resource.data.conversationId != null &&
        request.resource.data.senderId != null &&
        exists(/databases/(default)/documents/conversations/$(request.resource.data.conversationId)) &&
        isConversationParticipant(request.resource.data.conversationId, request.auth.uid) &&
        isConversationActive(request.resource.data.conversationId) &&
        request.resource.data.senderId == request.auth.uid &&
        // Validate required fields
        request.resource.data.keys().hasAll(['conversationId', 'senderId', 'senderName', 'type', 'text']) &&
        request.resource.data.conversationId is string &&
        request.resource.data.senderId is string &&
        request.resource.data.senderName is string &&
        request.resource.data.type in ['text', 'image', 'incident_share', 'system'] &&
        request.resource.data.text is string &&
        request.resource.data.text.size() <= 2000;
      
      // Allow update for read receipts and editing own messages
      allow update: if isAuthenticated() &&
        exists(/databases/(default)/documents/conversations/$(resource.data.conversationId)) &&
        isConversationParticipant(resource.data.conversationId, request.auth.uid) &&
        isConversationActive(resource.data.conversationId) &&
        (
          // Updating read receipts
          (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['readBy', 'updatedAt'])) ||
          // Editing own message (text only)
          (request.auth.uid == resource.data.senderId &&
           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['text', 'isEdited', 'updatedAt']) &&
           request.resource.data.text is string &&
           request.resource.data.text.size() <= 2000)
        );
      
      // Allow delete only for message sender or conversation creator
      allow delete: if isAuthenticated() &&
        exists(/databases/(default)/documents/conversations/$(resource.data.conversationId)) &&
        (request.auth.uid == resource.data.senderId ||
         request.auth.uid == get(/databases/(default)/documents/conversations/$(resource.data.conversationId)).data.createdBy);
    }
    
    // Message attachments collection (for future file references)
    match /message_attachments/{attachmentId} {
      allow read, write: if isAuthenticated() &&
        exists(/databases/(default)/documents/messages/$(resource.data.messageId)) &&
        exists(/databases/(default)/documents/conversations/$(get(/databases/(default)/documents/messages/$(resource.data.messageId)).data.conversationId)) &&
        isConversationParticipant(
          get(/databases/(default)/documents/messages/$(resource.data.messageId)).data.conversationId, 
          request.auth.uid
        );
    }
    
    // Existing collections - incident, daily_logs, etc.
    // TODO: Add/update rules for existing collections as needed
    match /incidents/{incidentId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists) + Data validation
      allow create: if isAuthenticated() && 
        request.resource.data.childId != null && 
        hasChildAccess(request.auth.uid, request.resource.data.childId) &&
        !(hasChildRoleForRequest('therapists')) &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId', 'type']) &&
        request.resource.data.type is string &&
        request.resource.data.type.size() > 0;
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE  
      allow update: if isAuthenticated() && 
        resource.data.childId != null && 
        hasChildAccess(request.auth.uid, resource.data.childId) && 
        (isChildOwner(resource.data.childId) || 
         (request.auth.uid == resource.data.createdBy && !hasChildRoleForResource('therapists')) ||
         (request.resource.data.status == 'deleted' && (isChildOwner(resource.data.childId) || request.auth.uid == resource.data.createdBy)));
    }
    
    match /dailyLogs/{logId} {
      // JOURNAL ENTRIES COLLECTION - Free-form notes about the child (non-medical)
      
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists) + Data validation
      allow create: if isAuthenticated() && 
        request.resource.data.childId != null && 
        hasChildAccess(request.auth.uid, request.resource.data.childId) &&
        !(hasChildRoleForRequest('therapists')) &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId', 'text']) &&
        request.resource.data.text is string &&
        request.resource.data.text.size() > 0 &&
        request.resource.data.text.size() <= 10000 && // Max 10k chars for long text
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.status == 'active' &&
        // Optional fields validation
        (!('tags' in request.resource.data) || request.resource.data.tags is list) &&
        (!('category' in request.resource.data) || request.resource.data.category in ['mealtime','mood','sleep','milestone','challenge','medical_note']);
      
      // READ: All roles with child access (child must be active)
      allow read: if isAuthenticated() && 
        resource.data.childId != null && 
        hasChildAccess(request.auth.uid, resource.data.childId) &&
        exists(/databases/(default)/documents/children/$(resource.data.childId)) &&
        get(/databases/(default)/documents/children/$(resource.data.childId)).data.status == 'active';
      
      // UPDATE: Owner can edit any; others edit only their own (NOT Therapists) + SOFT DELETE
      allow update: if isAuthenticated() && 
        resource.data.childId != null && 
        hasChildAccess(request.auth.uid, resource.data.childId) && 
        // Immutable fields check
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.createdAt == resource.data.createdAt &&
        request.resource.data.childId == resource.data.childId &&
        // Update permissions
        (
          // Owner can edit any entry
          isChildOwner(resource.data.childId) ||
          // Author can edit own (non-therapists only)
          (request.auth.uid == resource.data.createdBy && !hasChildRoleForResource('therapists')) ||
          // Soft delete: owner or author can set status to deleted
          (request.resource.data.status == 'deleted' && 
           (isChildOwner(resource.data.childId) || request.auth.uid == resource.data.createdBy))
        ) &&
        // Text length validation for updates
        (!('text' in request.resource.data) || 
         (request.resource.data.text is string && 
          request.resource.data.text.size() > 0 && 
          request.resource.data.text.size() <= 10000)) &&
        // Optional fields validation for updates
        (!('tags' in request.resource.data) || request.resource.data.tags is list) &&
        (!('category' in request.resource.data) || request.resource.data.category in ['mealtime','mood','sleep','milestone','challenge','medical_note']);
    }
    
    match /journal_entries/{entryId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    match /follow_ups/{followUpId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    match /custom_categories/{categoryId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // User preferences
    match /user_preferences/{userId} {
      allow read, write: if isAuthenticated() && request.auth.uid == userId;
    }
    
    // === MISSING TOP-LEVEL COLLECTIONS ===
    
    // Daily care entries
    match /dailyCare/{careId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists) - RESTORED with fixed syntax
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // Daily logs 
    match /dailyLogs/{logId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // Medications
    match /medications/{medicationId} {
      // CREATE: Owner, Care Partners ONLY (NOT Caregivers, NOT Therapists) + Medical validation
      allow create: if canCreateMedical() &&
        hasValidMedicalFields();
      
      // READ: Owner, Care Partners, Therapists ONLY (NOT Caregivers)
      allow read: if canReadMedical();
      
      // UPDATE: Owner can edit any, Care Partners can edit own + SOFT DELETE + Medical validation
      allow update: if (canUpdateMedical() && hasValidMedicalFields()) || canSoftDelete();
    }
    
    // Side effects
    match /sideEffects/{effectId} {
      // CREATE: Owner, Care Partners ONLY (NOT Caregivers, NOT Therapists) + Medical validation
      allow create: if canCreateMedical() &&
        hasValidMedicalFields();
      
      // READ: Owner, Care Partners, Therapists ONLY (NOT Caregivers)
      allow read: if canReadMedical();
      
      // UPDATE: Owner can edit any, Care Partners can edit own + SOFT DELETE + Medical validation
      allow update: if (canUpdateMedical() && hasValidMedicalFields()) || canSoftDelete();
    }
    
    // Doctor visits
    match /doctorVisits/{visitId} {
      // CREATE: Owner, Care Partners ONLY (NOT Caregivers, NOT Therapists) + Medical validation
      allow create: if canCreateMedical() &&
        hasValidMedicalFields();
      
      // READ: Owner, Care Partners, Therapists ONLY (NOT Caregivers)
      allow read: if canReadMedical();
      
      // UPDATE: Owner can edit any, Care Partners can edit own + SOFT DELETE + Medical validation
      allow update: if (canUpdateMedical() && hasValidMedicalFields()) || canSoftDelete();
    }
    
    // Behaviors (global - no child access needed)
    match /behaviors/{behaviorId} {
      allow read: if isAuthenticated();
      allow write: if false; // Read-only for now
    }
    
    // Behavior templates (global - no child access needed) 
    match /behaviorTemplates/{templateId} {
      allow read: if isAuthenticated();
      allow write: if false; // Read-only for now
    }
    
    // Caregivers (global - no child access needed)
    match /caregivers/{caregiverId} {
      allow read, write: if isAuthenticated();
    }
    
    // Sensory inputs (global - no child access needed)
    match /sensory_inputs/{inputId} {
      allow read, write: if isAuthenticated();
    }
    
    // === MISSING COLLECTIONS ===
    
    // Daily habits (child-specific)
    match /daily_habits/{habitId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // Habit entries (child-specific)
    match /habit_entries/{entryId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // Custom habits (child-specific)  
    match /customHabits/{habitId} {
      // CREATE: Owner, Care Partners, Caregivers (NOT Therapists)
      allow create: if canCreateIncidentLogs() &&
        request.resource.data.keys().hasAll(['createdBy', 'createdAt', 'childId']);
      
      // READ: All roles with child access
      allow read: if canReadChildData();
      
      // UPDATE: Owner can edit all, others edit own (NOT Therapists) + SOFT DELETE
      allow update: if canUpdateIncidentLogs() || canSoftDelete();
    }
    
    // Habits (global - no child access needed)
    match /habits/{habitId} {
      allow read: if isAuthenticated();
      allow write: if false; // Read-only for now
    }
    
    // Templates (global - no child access needed)
    match /templates/{templateId} {
      allow read, write: if isAuthenticated();
    }
    
    // Catch-all removed for security - all collections now have explicit rules
    
  }
}
